#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
mux.py - final mux stage for per-file pipeline.

Inputs:
  --source   original mkv
  --workdir  per-file workdir
  (tracks.json is expected at workdir/tracks.json, generated by bat generator)

Uses (if present):
  workdir/video/video-final.mkv
  workdir/00_meta/audio_manifest.json
  workdir/00_meta/demux_manifest.json
  workdir/chapters/chapters.xml

Output:
  <source_dir>/<basename>-av1.mkv

Requires:
  mkvmerge in PATH (MKVToolNix)
"""

from __future__ import annotations

import argparse
import atexit
import json
import os
import re
import shutil
import subprocess
import sys
from datetime import datetime
from pathlib import Path
from typing import Any, Dict, List, Optional, Tuple


# ---------------------------
# utils
# ---------------------------

STATE_DIR_NAME = ".state"
MUX_MARKER = "MUX_DONE"

class TeeStream:
    def __init__(self, stream, log_file) -> None:
        self._stream = stream
        self._log = log_file

    def write(self, s: str) -> int:
        try:
            self._stream.write(s)
            self._stream.flush()
        except Exception:
            pass
        if self._log is not None:
            try:
                self._log.write(s)
                self._log.flush()
            except Exception:
                self._log = None
        return len(s)

    def flush(self) -> None:
        try:
            self._stream.flush()
        except Exception:
            pass
        if self._log is not None:
            try:
                self._log.flush()
            except Exception:
                self._log = None

    def close_log(self) -> None:
        if self._log is None:
            return
        try:
            self._log.flush()
        except Exception:
            pass
        try:
            self._log.close()
        except Exception:
            pass
        self._log = None


def setup_logging(log_path: str, workdir: Optional[Path] = None) -> None:
    if not log_path:
        return
    p = Path(log_path)
    if not p.is_absolute() and workdir is not None:
        p = workdir / p
    p.parent.mkdir(parents=True, exist_ok=True)
    enc = getattr(sys.stdout, "encoding", None) or "utf-8"
    log_fh = p.open("a", encoding=enc, errors="replace")
    ts = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    try:
        log_fh.write(f"=== START mux {ts} ===\n")
        log_fh.flush()
    except Exception:
        pass
    orig_stdout = sys.stdout
    orig_stderr = sys.stderr
    tee_out = TeeStream(orig_stdout, log_fh)
    tee_err = TeeStream(orig_stderr, log_fh)
    sys.stdout = tee_out
    sys.stderr = tee_err

    def _cleanup() -> None:
        ts_end = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        try:
            log_fh.write(f"=== END mux {ts_end} ===\n")
            log_fh.flush()
        except Exception:
            pass
        sys.stdout = orig_stdout
        sys.stderr = orig_stderr
        tee_out.close_log()
        tee_err.close_log()

    atexit.register(_cleanup)

def eprint(*a: Any) -> None:
    print(*a, file=sys.stderr)

def ensure_dir(p: Path) -> None:
    p.mkdir(parents=True, exist_ok=True)

def marker_path(workdir: Path) -> Path:
    return workdir / STATE_DIR_NAME / MUX_MARKER

def write_marker(workdir: Path) -> None:
    p = marker_path(workdir)
    p.parent.mkdir(parents=True, exist_ok=True)
    p.write_text("ok\n", encoding="utf-8")

def read_json(p: Path) -> Any:
    return json.loads(p.read_text(encoding="utf-8"))

def write_json(p: Path, obj: Any) -> None:
    ensure_dir(p.parent)
    p.write_text(json.dumps(obj, ensure_ascii=False, indent=2), encoding="utf-8")

def which_or(name: str) -> str:
    return shutil.which(name) or name

def norm_type(t: str) -> str:
    v = (t or "").strip().lower()
    if v.startswith("vid") or v == "video":
        return "video"
    if v.startswith("aud") or v == "audio":
        return "audio"
    if v.startswith("sub") or v == "subtitle":
        return "sub"
    return v

def is_skip(status: str) -> bool:
    return (status or "").strip().upper() == "SKIP"

def is_copy(status: str) -> bool:
    return (status or "").strip().upper() == "COPY"

def is_edit(status: str) -> bool:
    return (status or "").strip().upper() == "EDIT"

def sanitize_for_cmd_log(s: str) -> str:
    # only for printing command; doesn't affect execution
    return s.replace("\n", " ").replace("\r", " ")

def run_cmd(cmd: List[str]) -> None:
    print("[cmd]", " ".join(sanitize_for_cmd_log(x) for x in cmd))
    p = subprocess.run(
        cmd,
        stdout=subprocess.PIPE,
        stderr=subprocess.STDOUT,
        text=True,
        encoding="utf-8",
        errors="replace",
        check=False,
    )
    if p.stdout:
        print(p.stdout, end="" if p.stdout.endswith("\n") else "\n")
    if p.returncode != 0:
        raise RuntimeError(f"mkvmerge_failed_rc_{p.returncode}")

def mkvmerge_json(mkvmerge: str, source: Path) -> Dict[str, Any]:
    cmd = [mkvmerge, "-J", str(source)]
    p = subprocess.run(
        cmd,
        stdout=subprocess.PIPE,
        stderr=subprocess.STDOUT,
        text=True,
        encoding="utf-8",
        errors="replace",
        check=False,
    )
    if p.returncode != 0:
        raise RuntimeError(f"mkvmerge_J_failed_rc_{p.returncode}")
    try:
        return json.loads(p.stdout)
    except Exception as ex:
        raise RuntimeError(f"mkvmerge_J_json_parse_failed_{ex}")

def get_src_track_codec(mkvj: Dict[str, Any], track_id: int) -> str:
    for t in mkvj.get("tracks") or []:
        if int(t.get("id", -1)) == int(track_id):
            props = t.get("properties") or {}
            return str(props.get("codec_id") or "")
    return ""

def ext_from_sub_codec(codec_id: str) -> str:
    c = (codec_id or "").upper()
    if "S_TEXT/ASS" in c:
        return ".ass"
    if "S_TEXT/SSA" in c:
        return ".ssa"
    if "S_TEXT/UTF8" in c:
        return ".srt"
    if "S_TEXT/WEBVTT" in c:
        return ".vtt"
    if "S_HDMV/PGS" in c:
        return ".sup"
    if "S_VOBSUB" in c:
        return ".sub"
    return ".sub"

def mime_from_ext(path: Path) -> str:
    ext = path.suffix.lower()
    # common attachments in anime: ttf/otf, images
    if ext == ".ttf":
        return "application/x-truetype-font"
    if ext == ".otf":
        return "application/vnd.ms-opentype"
    if ext == ".jpg" or ext == ".jpeg":
        return "image/jpeg"
    if ext == ".png":
        return "image/png"
    if ext == ".webp":
        return "image/webp"
    # leave empty => mkvmerge will try to guess
    return ""

def bool_yesno(v: Optional[str]) -> Optional[str]:
    if v is None:
        return None
    s = str(v).strip().lower()
    if s in ("1", "true", "yes", "y", "on"):
        return "yes"
    if s in ("0", "false", "no", "n", "off"):
        return "no"
    return None


# ---------------------------
# plan loading
# ---------------------------

def load_tracks(workdir: Path) -> List[Dict[str, Any]]:
    tracks_path = workdir / "tracks.json"
    if not tracks_path.exists():
        raise RuntimeError("missing_tracks_json")
    obj = read_json(tracks_path)
    tracks = obj.get("tracks")
    if not isinstance(tracks, list):
        raise RuntimeError("invalid_tracks_json_tracks")
    return [t for t in tracks if isinstance(t, dict)]

def load_audio_manifest(workdir: Path) -> Optional[Dict[str, Any]]:
    p = workdir / "00_meta" / "audio_manifest.json"
    return read_json(p) if p.exists() else None

def load_demux_manifest(workdir: Path) -> Optional[Dict[str, Any]]:
    p = workdir / "00_meta" / "demux_manifest.json"
    return read_json(p) if p.exists() else None

def pick_chapters_path(workdir: Path, demux_manifest: Optional[Dict[str, Any]]) -> Optional[Path]:
    # prefer explicit chapters.xml in workdir/chapters
    p1 = workdir / "chapters" / "chapters.xml"
    if p1.exists() and p1.stat().st_size > 0:
        return p1
    if demux_manifest and isinstance(demux_manifest.get("chapters"), dict):
        ch = demux_manifest["chapters"].get("path")
        if ch:
            p = Path(ch)
            if not p.is_absolute():
                p = workdir / p
            if p.exists() and p.stat().st_size > 0:
                return p
    return None

def pick_attachments(workdir: Path, demux_manifest: Optional[Dict[str, Any]]) -> List[Dict[str, Any]]:
    out: List[Dict[str, Any]] = []
    if not demux_manifest:
        return out
    atts = demux_manifest.get("attachments")
    if not isinstance(atts, list):
        return out
    for a in atts:
        if not isinstance(a, dict):
            continue
        p = a.get("path")
        if not p:
            continue
        pp = Path(p)
        if not pp.is_absolute():
            pp = workdir / pp
        if not pp.exists() or pp.stat().st_size == 0:
            continue
        out.append({
            "path": str(pp),
            "file_name": a.get("file_name") or pp.name,
            "content_type": a.get("content_type") or "",
        })
    return out

def pick_extracted_subs(workdir: Path, demux_manifest: Optional[Dict[str, Any]]) -> Dict[int, Path]:
    """
    Returns map: trackId -> extracted subtitle file path
    """
    res: Dict[int, Path] = {}
    if not demux_manifest:
        return res
    subs = demux_manifest.get("subs")
    if not isinstance(subs, list):
        return res
    for s in subs:
        if not isinstance(s, dict):
            continue
        tid = s.get("trackId")
        p = s.get("path")
        if tid is None or not p:
            continue
        try:
            tid_i = int(tid)
        except Exception:
            continue
        pp = Path(p)
        if not pp.is_absolute():
            pp = workdir / pp
        if pp.exists() and pp.stat().st_size >= 1:
            res[tid_i] = pp
    return res

def pick_audio_outputs(workdir: Path, audio_manifest: Optional[Dict[str, Any]]) -> Dict[int, Path]:
    """
    Returns map: trackId -> primary output file path
    """
    res: Dict[int, Path] = {}
    if not audio_manifest:
        return res
    outs = audio_manifest.get("outputs")
    if not isinstance(outs, list):
        return res
    for o in outs:
        if not isinstance(o, dict):
            continue
        if str(o.get("role") or "") != "primary":
            continue
        try:
            tid = int(o.get("srcTrackId"))
        except Exception:
            continue
        op = o.get("outPath")
        if not op:
            continue
        p = Path(str(op))
        if not p.is_absolute():
            p = workdir / p
        if p.exists() and p.stat().st_size > 0:
            res[tid] = p
    return res


# ---------------------------
# mkvmerge args building
# ---------------------------

def add_track_meta_args(args: List[str], track_mux: Dict[str, Any], track_index_in_file: int = 0) -> None:
    """
    Adds mkvmerge metadata options for a specific track index in the *next input file*.
    For external single-track files, index is 0.
    """
    # language
    lang = track_mux.get("lang")
    if lang:
        args += ["--language", f"{track_index_in_file}:{lang}"]

    # track name
    name = track_mux.get("name")
    if name:
        args += ["--track-name", f"{track_index_in_file}:{name}"]

    # default / forced (strings "true"/"false" from GUI)
    d = bool_yesno(track_mux.get("default"))
    if d:
        args += ["--default-track", f"{track_index_in_file}:{d}"]

    f = bool_yesno(track_mux.get("forced"))
    if f:
        args += ["--forced-track", f"{track_index_in_file}:{f}"]


def build_mux_command(
    mkvmerge: str,
    source: Path,
    workdir: Path,
    tracks: List[Dict[str, Any]],
) -> Tuple[List[str], Dict[str, Any]]:
    mkvj = mkvmerge_json(mkvmerge, source)

    base = source.stem
    out_path = source.parent / f"{base}-av1.mkv"

    demux_manifest = load_demux_manifest(workdir)
    audio_manifest = load_audio_manifest(workdir)

    extracted_subs = pick_extracted_subs(workdir, demux_manifest)
    audio_out = pick_audio_outputs(workdir, audio_manifest)
    chapters = pick_chapters_path(workdir, demux_manifest)
    attachments = pick_attachments(workdir, demux_manifest)

    # Decide video input
    video_final = workdir / "video" / "video-final.mkv"
    have_video_final = video_final.exists() and video_final.stat().st_size > 0

    # Track lists from plan
    video_tracks = [t for t in tracks if norm_type(str(t.get("type") or "")) == "video" and not is_skip(str(t.get("trackStatus") or ""))]
    audio_tracks = [t for t in tracks if norm_type(str(t.get("type") or "")) == "audio" and not is_skip(str(t.get("trackStatus") or ""))]
    sub_tracks   = [t for t in tracks if norm_type(str(t.get("type") or "")) == "sub"   and not is_skip(str(t.get("trackStatus") or ""))]

    # mkvmerge base args
    args: List[str] = [mkvmerge, "-o", str(out_path), "--ui-language", "en"]

    # chapters
    if chapters:
        args += ["--chapters", str(chapters)]

    # Start building inputs.
    plan: Dict[str, Any] = {
        "output": str(out_path),
        "video_source": None,
        "audio_sources": [],
        "sub_sources": [],
        "chapters": str(chapters) if chapters else None,
        "attachments": attachments,
        "fallbacks": [],
    }

    # 1) Video
    if have_video_final:
        # external video file (single video track expected)
        args += ["--no-audio", "--no-subtitles"]
        # note: track meta for video usually not needed; language/name usually irrelevant for video,
        # but you can extend here if you store it.
        args += [str(video_final)]
        plan["video_source"] = str(video_final)
    else:
        # fallback: take video from source using COPY-selected video track ids
        # If multiple, include all.
        copy_vid_ids = [int(t.get("trackId")) for t in video_tracks if is_copy(str(t.get("trackStatus") or ""))]
        if not copy_vid_ids:
            raise RuntimeError("no_video_final_and_no_copy_video_tracks")
        args += ["--no-audio", "--no-subtitles", "--video-tracks", ",".join(str(x) for x in copy_vid_ids)]
        args += [str(source)]
        plan["video_source"] = f"source:{copy_vid_ids}"
        plan["fallbacks"].append("video_from_source")

    # 2) Audio
    # Primary approach: use audio_manifest outputs for each planned audio track
    # If missing for some track, fallback to source COPY.
    for t in sorted(audio_tracks, key=lambda x: int(x.get("trackId", 0))):
        tid = int(t.get("trackId"))
        status = str(t.get("trackStatus") or "")
        tmux = t.get("trackMux") or {}
        if not isinstance(tmux, dict):
            tmux = {}

        if tid in audio_out:
            ap = audio_out[tid]
            # metadata for single-track external file index=0
            add_track_meta_args(args, tmux, 0)
            args += [str(ap)]
            plan["audio_sources"].append({"trackId": tid, "path": str(ap), "from": "audio_manifest"})
        else:
            # fallback: allow COPY from source
            if is_copy(status):
                add_track_meta_args(args, tmux, 0)
                args += ["--audio-tracks", str(tid), "--no-video", "--no-subtitles", str(source)]
                plan["audio_sources"].append({"trackId": tid, "path": str(source), "from": "source_copy"})
                plan["fallbacks"].append(f"audio_{tid}_from_source")
            else:
                raise RuntimeError(f"missing_audio_output_track_{tid}")

    # 3) Subtitles
    # Prefer extracted subtitle files (demux_manifest). If absent, fallback to source COPY.
    for t in sorted(sub_tracks, key=lambda x: int(x.get("trackId", 0))):
        tid = int(t.get("trackId"))
        status = str(t.get("trackStatus") or "")
        tmux = t.get("trackMux") or {}
        if not isinstance(tmux, dict):
            tmux = {}

        if tid in extracted_subs:
            sp = extracted_subs[tid]
            add_track_meta_args(args, tmux, 0)
            args += [str(sp)]
            plan["sub_sources"].append({"trackId": tid, "path": str(sp), "from": "demux_manifest"})
        else:
            if is_copy(status):
                add_track_meta_args(args, tmux, 0)
                args += ["--subtitle-tracks", str(tid), "--no-video", "--no-audio", str(source)]
                plan["sub_sources"].append({"trackId": tid, "path": str(source), "from": "source_copy"})
                plan["fallbacks"].append(f"sub_{tid}_from_source")
            else:
                raise RuntimeError(f"missing_sub_file_track_{tid}")

    # 4) Attachments (from extracted files)
    # Add at the end as global options; mkvmerge applies them to output
    for a in attachments:
        p = Path(a["path"])
        name = a.get("file_name") or p.name
        ctype = a.get("content_type") or ""
        args += ["--attachment-name", str(name)]
        if ctype:
            args += ["--attachment-mime-type", str(ctype)]
        else:
            # optional: infer from ext if missing
            m = mime_from_ext(p)
            if m:
                args += ["--attachment-mime-type", m]
        args += ["--attach-file", str(p)]

    return args, plan


# ---------------------------
# main
# ---------------------------

def main(argv: Optional[List[str]] = None) -> int:
    ap = argparse.ArgumentParser(prog="mux")
    ap.add_argument("--source", required=True)
    ap.add_argument("--workdir", required=True)
    ap.add_argument("--mkvmerge", default="mkvmerge", help="Path to mkvmerge (MKVToolNix)")
    ap.add_argument("--log", default="", help="Optional log file path (relative to --workdir if not absolute)")
    args = ap.parse_args(argv)

    source = Path(args.source)
    workdir = Path(args.workdir)
    mkvmerge = which_or(args.mkvmerge)
    setup_logging(args.log, workdir)
    marker = marker_path(workdir)
    if marker.exists():
        print(f"[mux] skip: marker exists: {marker}")
        return 0

    try:
        if not source.exists():
            raise RuntimeError("missing_source")
        if source.suffix.lower() != ".mkv":
            raise RuntimeError("source_not_mkv")
        if not workdir.exists():
            raise RuntimeError("missing_workdir")
        if not (Path(mkvmerge).exists() or shutil.which(mkvmerge)):
            raise RuntimeError("missing_mkvmerge")

        tracks = load_tracks(workdir)

        cmd, plan = build_mux_command(mkvmerge, source, workdir, tracks)

        # Save manifest for debugging/reproducibility
        write_json(workdir / "00_meta" / "mux_manifest.json", {
            "source": str(source),
            "workdir": str(workdir),
            "mkvmerge": str(mkvmerge),
            "plan": plan,
            "command": cmd,
        })

        run_cmd(cmd)

        print("[mux] OK")
        write_marker(workdir)
        return 0

    except Exception as ex:
        eprint(f"[mux] ERROR: {ex}")
        return 1


if __name__ == "__main__":
    raise SystemExit(main())
